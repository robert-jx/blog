import{_ as i,c as a,o as p,ae as t}from"./chunks/framework.CLNW5JS9.js";const o=JSON.parse('{"title":"基于 clip-path 实现的不规则区域放大效果","description":"","frontmatter":{},"headers":[],"relativePath":"vue/blowup-picture.md","filePath":"vue/blowup-picture.md"}'),l={name:"vue/blowup-picture.md"};function e(n,s,h,r,k,c){return p(),a("div",null,s[0]||(s[0]=[t(`<h1 id="基于-clip-path-实现的不规则区域放大效果" tabindex="-1">基于 clip-path 实现的不规则区域放大效果 <a class="header-anchor" href="#基于-clip-path-实现的不规则区域放大效果" aria-label="Permalink to &quot;基于 clip-path 实现的不规则区域放大效果&quot;">​</a></h1><h2 id="图片区域放大效果实现" tabindex="-1">图片区域放大效果实现 <a class="header-anchor" href="#图片区域放大效果实现" aria-label="Permalink to &quot;图片区域放大效果实现&quot;">​</a></h2><p>有个需求，需要根据后端传回来的点位数据来实现平面图里不规则区域放大的效果。</p><p>这里记录的是通过原生css3实现的方式：<strong>clip-path</strong></p><h3 id="何为clip-path" tabindex="-1">何为clip-path？ <a class="header-anchor" href="#何为clip-path" aria-label="Permalink to &quot;何为clip-path？&quot;">​</a></h3><p>clip-path是css的属性，其可以创建一个只有元素的部分区域可以显示的剪切区域。达到区域内的部分显示，区域外的隐藏的效果。</p><p>首先了解下clip-path使用方式：</p><h3 id="inset" tabindex="-1">inset <a class="header-anchor" href="#inset" aria-label="Permalink to &quot;inset&quot;">​</a></h3><p>将元素裁剪成一个矩形</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">clip-path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: inset( &lt;距离元素上面的距离</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,&lt;距离元素右面的距离</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ,&lt;距离元素下面的距离</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,&lt;距离元素左面的距离</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,&lt;圆角边框</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ），括号内的值类似于margin、padding值的写法。</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">例：</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">clip-path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: inset(2px 2px 20px 20px round 10px);</span></span></code></pre></div><h3 id="circle" tabindex="-1">circle <a class="header-anchor" href="#circle" aria-label="Permalink to &quot;circle&quot;">​</a></h3><p>将元素裁剪成一个圆形</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">clip-path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: circle(圆的半径 at 圆心)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">例：</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">clip-path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: circle(40px at 50% 50%)</span></span></code></pre></div><h3 id="ellipse" tabindex="-1">ellipse <a class="header-anchor" href="#ellipse" aria-label="Permalink to &quot;ellipse&quot;">​</a></h3><p>将元素裁剪成一个椭圆</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">clip-path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: ellipse(圆的水平半径 圆的垂直半径 at 圆心)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">例：</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">clip-path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: ellipse(20px 40px at 50% 50%)</span></span></code></pre></div><h3 id="polygon" tabindex="-1">polygon <a class="header-anchor" href="#polygon" aria-label="Permalink to &quot;polygon&quot;">​</a></h3><p>将元素裁剪成多边形</p><p>其实就是描点，多点连线，最少需要三个点，以距离左上角的长度为单位，可参考canvas的画布坐标写法。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">clip-path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: polygon(&lt;距离左上角的X轴长度  距离左上角Y轴的长度</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，&lt;距离左上角的X轴长度  距离左上角Y轴的长度</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">，&lt;距离左上角的X轴长度  距离左上角Y轴的长度</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">例：</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">clip-path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: polygon(40px 0px, 0px  80px, 80px 80px);</span></span></code></pre></div><p>了解了用法之后，那么我的初步思路就是：</p><p>数据的处理，对每个数据进行处理，添加一个path属性，里面存放clip-path的各种拼接好的值</p><p>可以用一层作为底图展示平面图，然后再通过循环遍历数组给容器添加裁剪后的图片（均使用同一图片做为背景图供clip-path去裁剪）</p><p>之后给这些裁剪好的图片添加一个hover类，添加一个translate效果，实现放大效果。</p><p>具体的可以参考下demo👇</p><p>demo连接：<a href="https://github.com/robert-jx/blowup-picture" target="_blank" rel="noreferrer">https://github.com/robert-jx/blowup-picture</a></p>`,26)]))}const E=i(l,[["render",e]]);export{o as __pageData,E as default};
